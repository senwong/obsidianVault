
## 闭包

特点：可以访问创建闭包的函数的局部变量，即使创建它的函数已经从stack中弹出了
实现原理：
每个函数有自己的函数作用域，或者叫context，创建函数执行完成之后，返回的函数对象，函数对象存放在堆上，函数对象会关联闭包对象，所以即使创建函数已经执行完毕，函数仍然能访问捕获的变量。


## new
new function时发生了什么？
1. 创建一个新的实例对象，把this指向实例对象
2. 把实例对象的__proto__指向函数的prototype，如果函数的prototype不是对象，指向Object.prototype。

## for-of和for-in
for-of 是针对iterable object, 比如String, Array, Map, Set, Arguments
for-in是针对对象的可以枚举的字符串键。

## 事件循环

![[event_loop.png]]
1. 首先会执行同步代码
2. 同步代码执行完毕之后，会检查并执行微任务队列，比如Promise, Mutation Observer
3. 微任务队列清空之后，会检查宏任务队列，比如setTimeout, setInterval, xhr等，执行完一个宏任务之后，会检查并执行微任务队列，微任务执行完成后，再执行下一个宏任务，所有宏任务执行完成后，再次回到callStack。

参考：https://www.lumin.tech/articles/javascript-event-loop/

## chromium
chromium从输入地址后发生了什么？
整个浏览器有一个main process，负责处理浏览器UI，存储，网络。按下回车之后浏览器UI线程会处理这个navigation，开始后会把让负责网络请求的thread去处理请求，涉及到网络部分，域名解析，http请求链接。网络请求处理完成之后，会根据返回结果的类型，这里假如返回的是html文件。
如果返回的是html文件，则会启动render process（chromium中是blink，safari中是webkit），对html文件处理。
html文件是咋被处理的呢？生成dom树，css生成cssDom树（绘制完成后放到gpu buffer里，GPU渲染画面），通过v8执行javascript。
v8执行JavaScript是，现词法分析生成token， 语法分析生成ast，解释器通过ast生成字节码（bytecode）并执行，解释器使用的是自己实现的寄存器，不是机器码，机器码使用的是操作系统提供的指令集，相当于是一个虚拟机。
除此之外，v8有一个负责优化的编译器，turboFan, 会把在interpreter执行过程中的热点代码编译成machine code以提高性能，


# 框架

## react原理

react setState之后发生了什么？
setState会把更新放到队列当中，短时间内同一个状态的多次更新会合并，
批量更新




## react hook原理

## react合成事件
目的：
1. 为了兼容不同浏览器，
实现原理：
react17事件是委托在document or，react17是挂在的容器节点上，




## webpack循环依赖
如何判断图是否有环

## 为什么找新工作


## Number.MAX_SAFE_INTERGER
为什么是2^53 -1?
安全数的定义：数字n能被精确的表示，并且n+1的的表示不能是n的表示
超过2^53-1之后，会有n === n+1的现象
因为JS中Number是IEEE754规范，数字是64位双精度浮点数组成，1 + 11 + 52组成1位符号数，11位指数，52位


## webpack

1. compiler等于整个webpack的生命周期，compilation是一次编译的生命周期；
2. 


## cdn原理

CDN 的工作原理 就是将源站的资源缓存CDN各个节点上，当请求命中了某个节点的资源缓存时，立即返回客户端，避免每个请求的资源都通过源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。

## 为什么多域名部署
http1最多支持同一个域名6个tcp链接，超过的请求需要排队等待之前的请求完成。多域名可以规避这种现象。


## 测试，单元，集成，E2E
单元测试：针对最小可测单元进程测试，比如一个类，一个函数，
集成测试：把多个单元组合在一起测试，测试模块之间的交互是否正确，比如一个后端接口和前端页面进行测试，一个子系统和其他子系统进行测试。
E2E：模拟用户真实操作，验证整个系统是否按照预期工作。

## cjs实现esm



## react-loadable
react-loadable也是使用的import 函数进行动态加载

## suspense-react
suspense的使用场景：
1. 如果子组件需要异步获取数据，在组件获取数据的过程中，显示fallback组件。
2. 如果子组件是一个使用`React.lazy`异步加载的组件，在子组件加载的过程中，显示fallback组件。
工作原理：
1. 子组件是异步获取数据的，`const user = use(fetchData("/api/getUser"))`，需要在`use`方法中`throw` 出一个`promise`对象，react在渲染过程捕获一个异常，异常内容是一个`promise`对象，那么可以通过`promise`对象知道子组件数据是否加载完成，未加载时展示fallback。
2. 如果子组件是异步组件，`React.lazy`返回的是一个`import()`返回的`promise`，`promise`完成后得到组件，然后加载组件。


## git rebase和merge有什么区别