# JavaScript
## 闭包

特点：可以访问创建闭包的函数的局部变量，即使创建它的函数已经从stack中弹出了
实现原理：
每个函数有自己的函数作用域，或者叫context，创建函数执行完成之后，返回的函数对象，函数对象存放在堆上，函数对象会关联闭包对象，所以即使创建函数已经执行完毕，函数仍然能访问捕获的变量。


## new
new function时发生了什么？
1. 创建一个新的实例对象，把this指向实例对象
2. 把实例对象的__proto__指向函数的prototype，如果函数的prototype不是对象，指向Object.prototype。

## for-of和for-in
for-of 是针对iterable object, 比如String, Array, Map, Set, Arguments
for-in是针对对象的可以枚举的字符串键。

## 事件循环

![[event_loop.png]]
1. 首先会执行同步代码
2. 同步代码执行完毕之后，会检查并执行微任务队列，比如Promise, Mutation Observer
3. 微任务队列清空之后，会检查宏任务队列，比如setTimeout, setInterval, xhr等，执行完一个宏任务之后，会检查并执行微任务队列，微任务执行完成后，再执行下一个宏任务，所有宏任务执行完成后，再次回到callStack。

参考：https://www.lumin.tech/articles/javascript-event-loop/

## chromium
chromium从输入地址后发生了什么？
整个浏览器有一个main process，负责处理浏览器UI，存储，网络。按下回车之后浏览器UI线程会处理这个navigation，开始后会把让负责网络请求的thread去处理请求，涉及到网络部分，域名解析，http请求链接。网络请求处理完成之后，会根据返回结果的类型，这里假如返回的是html文件。
如果返回的是html文件，则会启动render process（chromium中是blink，safari中是webkit），对html文件处理。
html文件是咋被处理的呢？生成dom树，css生成cssDom树（绘制完成后放到gpu buffer里，GPU渲染画面），通过v8执行javascript。
v8执行JavaScript是，现词法分析生成token， 语法分析生成ast，解释器通过ast生成字节码（bytecode）并执行，解释器使用的是自己实现的寄存器，不是机器码，机器码使用的是操作系统提供的指令集，相当于是一个虚拟机。
除此之外，v8 有一个负责优化的编译器，turboFan, 会把在interpreter执行过程中的热点代码编译成machine code以提高性能，


# 框架

## react原理

react setState之后发生了什么？
setState会把更新放到队列当中，短时间内同一个状态的多次更新会合并，
批量更新




## react hook原理

## react合成事件
目的：
1. 为了兼容不同浏览器，
实现原理：
react17事件是委托在document or，react17是挂在的容器节点上，




## webpack循环依赖
如何判断图是否有环

## 为什么找新工作


## Number.MAX_SAFE_INTERGER
为什么是2^53 -1?
安全数的定义：数字n能被精确的表示，并且n+1的的表示不能是n的表示
超过2^53-1之后，会有n === n+1的现象
因为JS中Number是IEEE754规范，数字是64位双精度浮点数组成，1 + 11 + 52组成1位符号数，11位指数，52位


## webpack

1. compiler等于整个webpack的生命周期，compilation是一次编译的生命周期；
2. 


## cdn原理

CDN 的工作原理 就是将源站的资源缓存CDN各个节点上，当请求命中了某个节点的资源缓存时，立即返回客户端，避免每个请求的资源都通过源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。

## 为什么多域名部署
http1最多支持同一个域名6个tcp链接，超过的请求需要排队等待之前的请求完成。多域名可以规避这种现象。


## 测试，单元，集成，E2E
单元测试：针对最小可测单元进程测试，比如一个类，一个函数，
集成测试：把多个单元组合在一起测试，测试模块之间的交互是否正确，比如一个后端接口和前端页面进行测试，一个子系统和其他子系统进行测试。
E2E：模拟用户真实操作，验证整个系统是否按照预期工作。

## cjs实现esm



## react-loadable
react-loadable也是使用的import 函数进行动态加载

## suspense-react
suspense的使用场景：
1. 如果子组件需要异步获取数据，在组件获取数据的过程中，显示fallback组件。
2. 如果子组件是一个使用`React.lazy`异步加载的组件，在子组件加载的过程中，显示fallback组件。
工作原理：
1. 子组件是异步获取数据的，`const user = use(fetchData("/api/getUser"))`，需要在`use`方法中`throw` 出一个`promise`对象，react在渲染过程捕获一个异常，异常内容是一个`promise`对象，那么可以通过`promise`对象知道子组件数据是否加载完成，未加载时展示fallback。
2. 如果子组件是异步组件，`React.lazy`返回的是一个`import()`返回的`promise`，`promise`完成后得到组件，然后加载组件。


## git rebase和merge有什么区别

#### 现象
以feature和master分支为例，把master分支merge到feature，git merge会在feature分支产生一个新的commit，新的commit指向master分支。
如果是把master分支rebase到feature分支，feature分支会移动到master分支前面，和master分支会整合到一个分支上，feature分支上的commit会生成新的commit。
#### 优缺点
rebase：好处：可以产生线性的commit 记录，review时更加直观。
merge：好处：不会破坏原来的提交记录，缺点：会产生新的commit记录。

![[rebase-1.png]]
![[rebase-2.png]]
![[rebase-3.png]]
![[rebase-4.png]]

# 网络
## TCP三次握手

![[tcp_three_way_handshake.png]]

1. 客户端发送一个请求到服务端，请求头中设置SYN=1，设置Sequence Number为一个随机数
2. 服务端接收到请求后，回复给客户端一个请求，设置请求头SYN=1, ACK=1;  设置Sequence Number为随机数，设置Acknowledge Number为之前的Sequence number + 1。
3. 客户端接受到服务端的回复之后，会再发送一个请求给服务端，设置SYN=1, ACK=1; 设置Sequence Number为接收到的Acknowledge Number，设置Acknowledge Number为接收到的Sequence Number + 1;


## Head Of Line Blocking

HOF问题-队头阻塞问题：主要是指一个资源阻塞了其他资源的现象。

http1.1的队头阻塞问题
举例：如果服务器返回`script.js`和`style.css`，两个文件按顺序返回，http header字段content-length指定对应文件内容
![[http1_1_1.png]]
如果`script.js`文件特别大时，服务器会先把`script.js`的包发送完成后，再发送`style.css`的包。
```
11111111111111111111222
```
解决方式就是多路复用`multiplexing`，`script.js`和`style.css`混合交错发送。
```
1212121111111111111111111
```

http1.1由于必须每个chunk之间必须是连续的，不能实现这种效果。
http2的多路复用是如何实现的？http2在每个资源chunk前增加Data Frame，包含每个资源chunk的流id stream id和长度 length，

![[http1_1_vs_http_2.png]]

http2在发送多个文件时，可以混合交错发送多个文件：
![[http_2_packetizaiton_file.png]]



TCP队头阻塞：
tcp是有序连接，如果其中的某个packet丢失，丢失的数据包需要被重新传输。http2是基于tcp的，仍然有tcp的队头阻塞问题。

http3是如何解决tcp队头阻塞问题的：
http3在传输层使用QUIC替代tcp。quic层自带STREAM frame
![[http3.png]]


## TCP 粘包
英文：TCP sticky packet
### 什么是粘包？
tcp在传输数据时，发送方采用了Nagle算法会将多个小的包合并为一个大的包提高传输效率，如果接收方不知道这种合并，无法正确地还原数据。
#### Nagle算法


# addEventListener Capture
addEventListener函数的第第三个参数useCapture: boolean表示什么意思？先看下mdn上的说明
>
A boolean value indicating whether events of this type will be dispatched to the registered `listener` _before_ being dispatched to any `EventTarget` beneath it in the DOM tree. Events that are bubbling upward through the tree will not trigger a listener designated to use capture. Event bubbling and capturing are two ways of propagating events that occur in an element that is nested within another element, when both elements have registered a handle for that event. The event propagation mode determines the order in which elements receive the event. See [DOM Level 3 Events](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow) and [JavaScript Event order](https://www.quirksmode.org/js/events_order.html#link4) for a detailed explanation. If not specified, `useCapture` defaults to `false`.

一个布尔值，表示这个类型的时间是否在dom树下面的其他EventTarget触发之前，触发注册的listener。如果useCapture为true，则在冒泡上去的事件不会被捕获。冒泡和捕获是两种繁殖事件的方式在嵌套的元素之间。
dom事件在触发是会经历2个阶段（Phase）先是捕获阶段，再是冒泡阶段。useCapture: true表示时间在捕获阶段触发，false表示事件在冒泡阶段触发。


## css grid
css3中grid-template-columns到底怎么用的？每个函数是什么作用？函数有哪些参数，grid-column是怎么计算的？
入手：mdn，css标准
fit-content(x)： fit-content函数就是clamp(x, min-content, max-content)的作用
最负责的repeat function，先看下repeat的语法：`repeat( [ [<integer [1,∞]>] | auto-fill | auto-fit ], [<track-list>])`，